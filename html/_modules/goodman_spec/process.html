<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>goodman_spec.process &#8212; Goodman Pipelines 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Goodman Pipelines 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for goodman_spec.process</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf8 -*-</span>
<span class="sd">&quot;&quot;&quot;Module that handles intermediate processess</span>

<span class="sd">This module performs intermediate steps in the process to obtain a wavelength calibrated spectrum</span>
<span class="sd">the __call__ method returns a list contained uni-dimensional data extracted and the modified instance of ScienceObject</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>


<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;GTK3Agg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="k">import</span> <span class="n">fits</span>
<span class="kn">from</span> <span class="nn">astropy.modeling</span> <span class="k">import</span> <span class="n">models</span><span class="p">,</span> <span class="n">fitting</span>
<span class="kn">from</span> <span class="nn">goodman_ccd.core</span> <span class="k">import</span> <span class="n">add_wcs_keys</span>



<span class="c1"># FORMAT = &#39;%(levelname)s:%(filename)s:%(module)s: %(message)s&#39;</span>
<span class="c1"># log.basicConfig(level=log.INFO, format=FORMAT)</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;redspec.process&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Process"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.Process">[docs]</a><span class="k">class</span> <span class="nc">Process</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set of tools for extracting Goodman High Throughput Spectrograph data.</span>

<span class="sd">    This class needs a path parsed as an attribute of args (arguments object) and a ScienceObject object.</span>
<span class="sd">    The ScienceObject class is defined in the module redspec.py and in principle the current module was made to service</span>
<span class="sd">    it. This class has been tested to work very well independently given that you successfully provide the previously</span>
<span class="sd">    mentioned ScienceObject and respective path to the data location.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sci_obj</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize Process class</span>

<span class="sd">        It needs the sci_obj (ScienceObject instance) that contain information regarding the images being processed,</span>
<span class="sd">        such as, filename, science target name, etc. It also uses the arguments of the program that also are a class</span>
<span class="sd">        instance. For initialization it only uses the source path, or where the files are located.</span>

<span class="sd">        Args:</span>
<span class="sd">            sci_obj (object): Instance of ScienceObject.</span>
<span class="sd">            args (object): Runtime arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span> <span class="o">=</span> <span class="n">sci_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">file_name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">add_wcs_keys</span><span class="p">(</span><span class="n">fits</span><span class="o">.</span><span class="n">getheader</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                                                               <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">file_name</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lamps_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lamps_header</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_targets</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extracted_data</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extract_lamps</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call method for Process Class</span>

<span class="sd">        This method will call the other class&#39; methods that will identify, trace and extract the data. It will also</span>
<span class="sd">        modify attributes of the science_object attribute (instance of ScienceObject) and the return it along with the</span>
<span class="sd">        extracted data.</span>

<span class="sd">        Args:</span>
<span class="sd">            extract_lamps (bool): Whether it is necessary to extract the lamp to find the wavelength solution. If it&#39;s</span>
<span class="sd">             set to False it is assumed that a previously found wavelength solution will be applied.</span>

<span class="sd">        Returns:</span>
<span class="sd">            extracted (list): Contains two elements. self.extracted_data (object) and self.science_object (object)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Processing Science File : </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extract_lamps</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">lamp_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">lamp_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">lamp_count</span><span class="p">):</span>
                    <span class="n">lamp_data</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">lamp_file</span><span class="p">[</span><span class="n">lamp_index</span><span class="p">]))</span>
                    <span class="c1"># lamp_type = self.science_object.lamp_type[lamp_index]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lamps_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lamp_data</span><span class="p">)</span>
                    <span class="n">lamp_header</span> <span class="o">=</span> <span class="n">add_wcs_keys</span><span class="p">(</span>
                        <span class="n">fits</span><span class="o">.</span><span class="n">getheader</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">lamp_file</span><span class="p">[</span><span class="n">lamp_index</span><span class="p">])))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lamps_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lamp_header</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;There Are no lamps available for the target: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_spectra</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extracted_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span>

        <span class="n">extracted</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">extracted_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">extracted</span>

<div class="viewcode-block" id="Process.identify_spectra"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.Process.identify_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">identify_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Identify spectra in 2D (image) data</span>

<span class="sd">        This method takes a sample of the image and averages it in the dispersion direction, then analyze the spatial</span>
<span class="sd">        direction in search for peaks and count them as candidates to targets. In order to validate the target it will</span>
<span class="sd">        do a Voigt profile fit and if the new center deviates too much from the original location it will be discarded.</span>

<span class="sd">        Returns:</span>
<span class="sd">            identified_targets (list): Each element being and IdentifiedTarget instance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">y_size</span><span class="p">,</span> <span class="n">x_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Image is not 2D&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">y_size</span><span class="p">)</span>
        <span class="n">half_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.03</span> <span class="o">*</span> <span class="n">x_size</span><span class="p">)</span>
        <span class="n">sample_loc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_size</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="c1"># print x_size, y_size, int(0.05 * x_size)</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">sample_loc</span><span class="p">:</span><span class="n">sample_loc</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">half_width</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sample_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
        <span class="n">sample_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>

        <span class="c1"># search for spectra</span>
        <span class="n">all_found</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rising</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">falling</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">trend_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1.1</span> <span class="o">*</span> <span class="n">sample_median</span><span class="p">,</span> <span class="n">sample_std</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sample</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">rising</span> <span class="ow">and</span> <span class="n">trend_length</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="n">all_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                        <span class="n">trend_length</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">rising</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">falling</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">trend_length</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">falling</span> <span class="ow">and</span> <span class="n">trend_length</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>
                        <span class="n">trend_length</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">pass</span>
                    <span class="n">rising</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">falling</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">trend_length</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># validate targets</span>
        <span class="n">identified_targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spectrum</span> <span class="ow">in</span> <span class="n">all_found</span><span class="p">:</span>
            <span class="c1"># print spectrum</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y_size</span> <span class="o">-</span> <span class="n">spectrum</span><span class="p">))</span> <span class="o">-</span> <span class="mi">100</span><span class="p">):</span>
                <span class="c1"># print spectrum - i, spectrum + i, y_size - spectrum, x_size</span>
                <span class="k">if</span> <span class="n">sample</span><span class="p">[</span><span class="n">spectrum</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sample</span><span class="p">[(</span><span class="n">spectrum</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">sample</span><span class="p">[</span><span class="n">spectrum</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sample</span><span class="p">[(</span><span class="n">spectrum</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># plt.plot([x for x in range(spectrum - i, spectrum + i)], sample[spectrum - i:spectrum + i], color=&#39;g&#39;)</span>
                    <span class="n">sample_width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">sub_sample_x_axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spectrum</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">spectrum</span> <span class="o">+</span> <span class="n">i</span><span class="p">)]</span>
                        <span class="n">sub_sample</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="n">spectrum</span> <span class="o">-</span> <span class="n">i</span><span class="p">:</span><span class="n">spectrum</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span>
                        <span class="c1"># centroid = np.sum(sub_sample_x_axis * sub_sample) / np.sum(sub_sample)</span>
                        <span class="c1"># old procedure</span>
                        <span class="n">voigt_init</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Voigt1D</span><span class="p">(</span><span class="n">x_0</span><span class="o">=</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">amplitude_L</span><span class="o">=</span><span class="n">sample</span><span class="p">[</span><span class="n">spectrum</span><span class="p">],</span> <span class="n">fwhm_L</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">fwhm_G</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
                        <span class="n">fit_voigt</span> <span class="o">=</span> <span class="n">fitting</span><span class="o">.</span><span class="n">LevMarLSQFitter</span><span class="p">()</span>
                        <span class="n">voigt</span> <span class="o">=</span> <span class="n">fit_voigt</span><span class="p">(</span><span class="n">voigt_init</span><span class="p">,</span> <span class="n">sub_sample_x_axis</span><span class="p">,</span> <span class="n">sub_sample</span><span class="p">)</span>
                        <span class="c1"># print(voigt)</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">voigt</span><span class="o">.</span><span class="n">x_0</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">spectrum</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                            <span class="n">identified_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">IdentifiedTarget</span><span class="p">(</span>
                                <span class="n">amplitude</span><span class="o">=</span><span class="n">voigt</span><span class="o">.</span><span class="n">amplitude_L</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                <span class="n">mean</span><span class="o">=</span><span class="n">voigt</span><span class="o">.</span><span class="n">x_0</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                <span class="n">stddev</span><span class="o">=</span><span class="n">voigt</span><span class="o">.</span><span class="n">fwhm_L</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                <span class="n">fwhmg</span><span class="o">=</span><span class="n">voigt</span><span class="o">.</span><span class="n">fwhm_G</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                <span class="n">raw_width</span><span class="o">=</span><span class="n">sample_width</span><span class="p">,</span>
                                <span class="n">sample_loc</span><span class="o">=</span><span class="n">sample_loc</span><span class="p">))</span>
                            <span class="c1"># fitted_model = voigt</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">debug_mode</span><span class="p">:</span>
                                <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">spectrum</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">spectrum</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Spectrum width&#39;</span><span class="p">)</span>
                                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sub_sample_x_axis</span><span class="p">,</span> <span class="n">voigt</span><span class="p">(</span><span class="n">sub_sample_x_axis</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Voigt Fit&#39;</span><span class="p">)</span>
                                <span class="c1"># plt.axvline(centroid, color=&#39;k&#39;)</span>
                                <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">voigt</span><span class="o">.</span><span class="n">x_0</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Voigt x_0&#39;</span><span class="p">)</span>
                                <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Spectrum location&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Spectrum found at pixel </span><span class="si">%s</span><span class="s1"> is discarded&#39;</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">debug_mode</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">sample_median</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Median&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mf">1.1</span> <span class="o">*</span> <span class="n">sample_median</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;110% Median&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Data&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Pixel (Spatial Direction)&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Intensity&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="c1"># for target in identified_targets:</span>
            <span class="c1"># print target</span>
        <span class="k">return</span> <span class="n">identified_targets</span></div>

<div class="viewcode-block" id="Process.trace"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.Process.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targets</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds the trace of a spectrum given an initial location</span>

<span class="sd">        From the input data it finds the location of the spectrum in the image and an approximate width of six sigmas,</span>
<span class="sd">        with that information it takes a sample of the data just covering those limits to speed up the process.</span>
<span class="sd">        It takes about fifty sub-samples along the dispersion direction with a width of fifty pixels each.</span>
<span class="sd">        All the parameters can be changed with the variables half_n_sigma, ends_pix_spacing, n_samples and</span>
<span class="sd">        sample_width variables. The sub-samples are flattened along the dispersion direction using numpy.median and</span>
<span class="sd">        the location of the maximum value is recorded. Alternatively is possible to do a gaussian fit but my tests</span>
<span class="sd">        suggest is not much what you earn with this now is disabled by default. Enable it by changing do_gaussian_fit to</span>
<span class="sd">        True. Once there is a list of maximum locations a Chebyshev 1D of second order is fitted to define the trace.</span>
<span class="sd">        The Chebyshev function is defined for all the range of pixels in the dispersion direction of the image.</span>
<span class="sd">        This method also mask the regions that will be extracted as science target (or spectrum) and the regions</span>
<span class="sd">        that will be used for background subtractions. At first two regions are defined for each science target</span>
<span class="sd">        at each side by an offset defined by the background_offset variable and the same width as the science target&#39;s</span>
<span class="sd">        aperture. If there are background subtraction regions that fall into a science target they will be ignored.</span>
<span class="sd">        In that case only one background region will be used.</span>
<span class="sd">        If both subtraction regions are valid they will be averaged and then subtracted.</span>
<span class="sd">        If no background region are valid, no background subtraction will happen.</span>

<span class="sd">        Note:</span>
<span class="sd">            It is not worth doing gaussian fits to the sub samples since it will not improve the result. The only case</span>
<span class="sd">            this might be useful is the case when someone does an interpolation along the spatial direction.</span>

<span class="sd">        Args:</span>
<span class="sd">            targets (list): Each element is a class that stores the parameters of the gaussian fitted to the data in</span>
<span class="sd">                        previous steps. This data tells the location in the image of the target or targets.</span>

<span class="sd">        Returns:</span>
<span class="sd">            traces (list): Every element is a list with two elements. The first is the fitted Chebyshev and the</span>
<span class="sd">                       second and last is the width to be extracted.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># True enables gaussian fits and false disables it. Gaussian fit was left for experimental purposes</span>
        <span class="n">do_gaussian_fit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Voigt fits better</span>
        <span class="n">do_voigt_fit</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># half of number of sigmas to be sub_sampled</span>
        <span class="n">half_n_sigma</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="c1"># space allowance in pixels for extreme of images</span>
        <span class="n">ends_pix_spacing</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="c1"># Number of samples to be done in the dispersion direction</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="c1"># sample width must be smaller or equal than ends_pix_spacing</span>
        <span class="n">sample_width</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="c1"># Background offsets from target</span>
        <span class="c1"># background_offset = 5</span>

        <span class="n">traces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="c1"># target.print_all()</span>
            <span class="c1"># x_min = int(target.mean - half_n_sigma * target.stddev)</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">mean</span> <span class="o">-</span> <span class="n">target</span><span class="o">.</span><span class="n">raw_width</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
            <span class="c1"># x_max = int(target.mean + half_n_sigma * target.stddev)</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">mean</span> <span class="o">+</span> <span class="n">target</span><span class="o">.</span><span class="n">raw_width</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span>
            <span class="n">background_offset</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">width</span>
            <span class="c1"># target value in mask is -1, for background 0 for non-masked is 1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">regions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">width</span><span class="p">])</span>

            <span class="n">sample_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">sample_y</span> <span class="o">=</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">max_positions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">max_index</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">index_y</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_y</span> <span class="o">-</span> <span class="n">ends_pix_spacing</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">):</span>

                <span class="n">sub_sample</span> <span class="o">=</span> <span class="n">sample_data</span><span class="p">[:,</span> <span class="n">index_y</span><span class="p">:</span><span class="n">index_y</span> <span class="o">+</span> <span class="n">n_samples</span><span class="p">]</span>

                <span class="n">sub_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sub_sample</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># print sub_median</span>
                <span class="n">sub_x_axis</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_median</span><span class="p">))</span>

                <span class="n">sub_argmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sub_median</span><span class="p">)</span>
                <span class="n">sub_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sub_median</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">do_gaussian_fit</span><span class="p">:</span>
                    <span class="c1"># Will leave this here just in case someone wants to experiment</span>
                    <span class="c1"># A Voigt profile is better for this case</span>
                    <span class="n">gauss_init</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Gaussian1D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="n">sub_max</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="n">sub_argmax</span><span class="p">,</span> <span class="n">stddev</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
                    <span class="n">fit_gaussian</span> <span class="o">=</span> <span class="n">fitting</span><span class="o">.</span><span class="n">LevMarLSQFitter</span><span class="p">()</span>
                    <span class="n">gauss</span> <span class="o">=</span> <span class="n">fit_gaussian</span><span class="p">(</span><span class="n">gauss_init</span><span class="p">,</span> <span class="n">sub_x_axis</span><span class="p">,</span> <span class="n">sub_median</span><span class="p">)</span>
                    <span class="n">max_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gauss</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">x_min</span><span class="p">)</span>
                    <span class="n">max_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_y</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_width</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">do_voigt_fit</span><span class="p">:</span>
                    <span class="n">voigt_init</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Voigt1D</span><span class="p">(</span><span class="n">x_0</span><span class="o">=</span><span class="n">sub_argmax</span><span class="p">,</span> <span class="n">amplitude_L</span><span class="o">=</span><span class="n">sub_max</span><span class="p">,</span> <span class="n">fwhm_L</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">fwhm_G</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
                    <span class="n">fit_voigt</span> <span class="o">=</span> <span class="n">fitting</span><span class="o">.</span><span class="n">LevMarLSQFitter</span><span class="p">()</span>
                    <span class="n">voigt</span> <span class="o">=</span> <span class="n">fit_voigt</span><span class="p">(</span><span class="n">voigt_init</span><span class="p">,</span> <span class="n">sub_x_axis</span><span class="p">,</span> <span class="n">sub_median</span><span class="p">)</span>
                    <span class="n">max_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">voigt</span><span class="o">.</span><span class="n">x_0</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">x_min</span><span class="p">)</span>
                    <span class="n">max_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_y</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_width</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>
                    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sub_x_axis</span><span class="p">,</span> <span class="n">sub_median</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Data&#39;</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sub_x_axis</span><span class="p">,</span> <span class="n">voigt</span><span class="p">(</span><span class="n">sub_x_axis</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Voigt Fit&#39;</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Pixel (spatial direction)&#39;</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Intensity&#39;</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_argmax</span> <span class="o">+</span> <span class="n">x_min</span><span class="p">)</span>
                    <span class="n">max_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_y</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_width</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>

            <span class="c1"># chebyshev fitting for defining the trace</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">max_positions</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">:</span>
                <span class="n">chebyshev_init</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Chebyshev1D</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_y</span><span class="p">])</span>
                <span class="n">fit_cheb</span> <span class="o">=</span> <span class="n">fitting</span><span class="o">.</span><span class="n">LinearLSQFitter</span><span class="p">()</span>
                <span class="n">cheb</span> <span class="o">=</span> <span class="n">fit_cheb</span><span class="p">(</span><span class="n">chebyshev_init</span><span class="p">,</span> <span class="n">max_index</span><span class="p">,</span> <span class="n">max_positions</span><span class="p">)</span>


                <span class="c1"># Mask Background Extraction zones</span>
                <span class="c1"># TODO(simon): Define what to do in case no background extraction zone is suitable for use.</span>
                <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">:</span>
                    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">region</span>
                    <span class="n">b_low_min</span> <span class="o">=</span> <span class="n">x_min</span> <span class="o">-</span> <span class="n">background_offset</span> <span class="o">-</span> <span class="n">width</span>
                    <span class="n">b_low_max</span> <span class="o">=</span> <span class="n">x_min</span> <span class="o">-</span> <span class="n">background_offset</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">b_low_min</span><span class="p">,</span> <span class="n">b_low_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">b_high_min</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">+</span> <span class="n">background_offset</span>
                    <span class="n">b_high_max</span> <span class="o">=</span> <span class="n">x_max</span> <span class="o">+</span> <span class="n">background_offset</span> <span class="o">+</span> <span class="n">width</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">b_high_min</span><span class="p">,</span> <span class="n">b_high_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

                <span class="n">traces</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cheb</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">update_no_targets</span><span class="p">(</span><span class="n">add_one</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">debug_mode</span><span class="p">:</span>
                    <span class="n">fig1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">fig1</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="s1">&#39;Trace&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">clim</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;cubehelix&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">max_index</span><span class="p">,</span> <span class="n">max_positions</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Sampled values&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cheb</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_y</span><span class="p">)),</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Trace fit (Cheb)&#39;</span><span class="p">)</span>
                    <span class="c1"># plt.plot(max_index, max_positions, )</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Dispersion Direction&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Spatial Direction&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

                    <span class="n">half_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.03</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">sample_loc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
                    <span class="c1"># print x_size, y_size, int(0.05 * x_size)</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">sample_loc</span><span class="p">:</span><span class="n">sample_loc</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">half_width</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                    <span class="n">fig2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">fig2</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="s1">&#39;Masked Regions&#39;</span><span class="p">)</span>

                    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Masked Regions for Background extraction</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Spatial Direction&quot;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Intensity&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Target Mean&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Data Sample&#39;</span><span class="p">)</span>
                    <span class="c1"># plt.plot(self.region)</span>
                    <span class="n">limits</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">limits</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="c1"># check that the number of limits is even</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Uneven number of limits.&#39;</span><span class="p">)</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Removing last limit.&#39;</span><span class="p">)</span>
                        <span class="n">limits</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># print(limits)</span>
                    <span class="c1"># colors = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]</span>
                    <span class="c1"># colors_index = 0</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Background&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Object&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">limit_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span><span class="p">]]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">limits</span><span class="p">,</span> <span class="n">limit_index</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
                        <span class="c1"># colors_index += 1</span>
                        <span class="c1"># if colors_index == 3:</span>
                            <span class="c1"># colors_index = 0</span>
                    <span class="c1"># Watch out here! it works but might be an error.</span>
                    <span class="c1"># plt.xlim([target.mean - 200, target.mean + 200])</span>
                    <span class="c1"># plt.savefig(&quot;background-extraction-zones&quot; + self.science_object.name + &quot;_2.png&quot;, dpi=300)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Target at </span><span class="si">%s</span><span class="s1"> discarded&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">mean</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">traces</span></div>

<div class="viewcode-block" id="Process.mask"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.Process.mask">[docs]</a>    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask_min</span><span class="p">,</span> <span class="n">mask_max</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Masks the region that will be extracted</span>

<span class="sd">        The class Process has the attribute region (self.region) which is a section across the spatial direction of the</span>
<span class="sd">        image being processed. It is filled with ones (1) meaning that is _free zone_. Every time a new science</span>
<span class="sd">        target is found a mask will be created with -1 values. This type of mask has priority over all the rest.</span>
<span class="sd">        For every science target two background extraction zones are defined and masked with 0 but if they</span>
<span class="sd">        interfere with another science target they will be ignored.</span>


<span class="sd">        Args:</span>
<span class="sd">            mask_min (int): Starting point to the region to be masked</span>
<span class="sd">            mask_max (int): Ending point to the region to be masked</span>
<span class="sd">            value (int): Value to be replaced. -1 is for science targets and 0 for background regions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True or False: True if the masking suceeds or false if it fails.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">mask_min</span><span class="p">:</span><span class="n">mask_max</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">mask_min</span><span class="p">:</span><span class="n">mask_max</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">mask_min</span><span class="p">:</span><span class="n">mask_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Region </span><span class="si">%d</span><span class="s2">:</span><span class="si">%d</span><span class="s2"> is already masked&quot;</span><span class="p">,</span> <span class="n">mask_min</span><span class="p">,</span> <span class="n">mask_max</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Process.extract"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.Process.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts the spectra and returns an stack of science data and lamps</span>

<span class="sd">        Apart of traces this function makes use of the class attribute region which contains a mask for the extraction</span>
<span class="sd">        zones identified different for science targets and for background zones. The background subtraction is only</span>
<span class="sd">        used for the science targets since it would not make sense to do it for lamps.</span>

<span class="sd">        Args:</span>
<span class="sd">            traces (list): Contains a list per each science target previously detected. Every list has two elements</span>
<span class="sd">                that are: Chebyshev fitted to spectrum peaks along the full extension of the spectrum or along the</span>
<span class="sd">                full length of the dispersion axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sci_pack (list): The sci_pack is list that contains two main elements. The first contains all the data and</span>
<span class="sd">            the second contains the headers in the same order. In the first element, the first is always the science</span>
<span class="sd">            target and the following are lamps that are not calibrated yet. Again, the same order for the headers.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Loop through traces</span>
            <span class="n">sci_pack</span> <span class="o">=</span> <span class="n">SciencePack</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">trace_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">traces</span><span class="p">)):</span>
                <span class="c1"># Initial checks</span>
                <span class="n">history_headers</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">new_header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">lamp_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">all_lamps</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span> <span class="k">for</span> <span class="n">lamp_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">lamp_count</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;There are no lamps available for this Target.&#39;</span><span class="p">)</span>

                <span class="c1"># Extraction of data parsed as argument</span>
                <span class="n">chebyshev</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="n">trace_index</span><span class="p">]</span>
                <span class="c1"># log.debug(&quot;Offset for Background: %s&quot;, offset)</span>
                <span class="k">if</span> <span class="n">width</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">half_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">half_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

                <span class="c1"># Define background subtraction zones</span>
                <span class="c1"># TODO(simon): Make the background subtraction zones to follow the trace</span>
                <span class="n">background</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Found a mask limit.&quot;</span><span class="p">)</span>
                        <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">limit_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">width</span> <span class="ow">and</span>\
                                    <span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span><span class="p">]:</span><span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]:</span>
                        <span class="n">background</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
                        <span class="n">hist</span> <span class="o">=</span> <span class="s2">&quot;Defining background extraction zone [</span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2">] for target.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span><span class="p">],</span>
                                                                                            <span class="n">limits</span><span class="p">[</span><span class="n">limit_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">history_headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>

                <span class="c1"># Getting data shape</span>
                <span class="n">data_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">sci</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">unsubtracted</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">subtracted_background</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># Actual extraction</span>
                <span class="c1"># Avoid printing inside this loop since it goes through all the columns</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_y</span><span class="p">):</span>
                    <span class="c1"># Define limits of aperture for spectrum</span>
                    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">chebyshev</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="o">-</span> <span class="n">half_width</span>
                    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">chebyshev</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="o">+</span> <span class="n">half_width</span>
                    <span class="n">apnum1</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">trace_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">data_y</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                        <span class="n">hist</span> <span class="o">=</span> <span class="s1">&#39;Aperture for extraction [</span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">] at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">history_headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;APNUM1 = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">apnum1</span><span class="p">)</span>

                    <span class="c1"># If there are background extraction zones here are prepared to subtract</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">background</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">background_part</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">back</span> <span class="ow">in</span> <span class="n">background</span><span class="p">:</span>
                            <span class="n">part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">back</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">back</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">])</span>
                            <span class="c1"># background_median = np.median(self.data[back[0]:back[1], i])</span>
                            <span class="c1"># part2 = abs(x_max - x_min) * background_median</span>
                            <span class="n">background_part</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
                        <span class="n">background_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">background_part</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">background</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">background_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">background</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">background</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">background_data</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># Stored for debugging process</span>
                    <span class="c1"># print background_data</span>
                    <span class="n">subtracted_background</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">background_data</span><span class="p">)</span>
                    <span class="n">unsubtracted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>

                    <span class="n">data_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">background_data</span>
                    <span class="c1"># print(&#39;DATA POINT &#39;, np.sum(self.data[x_min:x_max, i]), background_data)</span>
                    <span class="n">sci</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_point</span><span class="p">)</span>

                    <span class="c1"># Lamp extraction</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lamps_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">limit_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">lamp_count</span><span class="p">):</span>
                            <span class="n">lamp_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lamps_data</span><span class="p">[</span><span class="n">limit_index</span><span class="p">][</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                            <span class="n">all_lamps</span><span class="p">[</span><span class="n">limit_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_lamps</span><span class="p">[</span><span class="n">limit_index</span><span class="p">],</span> <span class="n">lamp_point</span><span class="p">)</span>
                <span class="c1"># Construction of extracted_object (to be returned)</span>
                <span class="c1"># extracted_object.append(np.array(sci))</span>
                <span class="n">sci_pack</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sci</span><span class="p">))</span>
                <span class="c1"># if int(trace_index + 1) &gt; 1:</span>
                <span class="c1">#     new_header.rename_keyword(&#39;APNUM1&#39;, &#39;APNUM%s&#39; % str(int(trace_index + 1)))</span>
                <span class="n">new_header</span><span class="p">[</span><span class="s1">&#39;APNUM1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">apnum1</span>
                <span class="k">if</span> <span class="n">history_headers</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="k">for</span> <span class="n">hist</span> <span class="ow">in</span> <span class="n">history_headers</span><span class="p">:</span>
                        <span class="n">new_header</span><span class="p">[</span><span class="s1">&#39;HISTORY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hist</span>
                <span class="c1"># headers.append(new_header)</span>
                <span class="n">sci_pack</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="n">new_header</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lamps_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">lamp_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">lamp_count</span><span class="p">):</span>
                        <span class="c1"># extracted_object.append(np.array(all_lamps[lamp_index]))</span>
                        <span class="n">sci_pack</span><span class="o">.</span><span class="n">add_lamp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_lamps</span><span class="p">[</span><span class="n">lamp_index</span><span class="p">]))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lamps_header</span><span class="p">[</span><span class="n">lamp_index</span><span class="p">][</span><span class="s1">&#39;APNUM1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">apnum1</span>
                        <span class="n">sci_pack</span><span class="o">.</span><span class="n">add_lamp_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lamps_header</span><span class="p">[</span><span class="n">lamp_index</span><span class="p">])</span>
                        <span class="c1"># headers.append(self.lamps_header[lamp_index])</span>
                <span class="c1">#</span>
                <span class="c1"># Plot background subtraction</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">debug_mode</span><span class="p">:</span>
                    <span class="c1"># sci_sample = sci[int(len(sci) / 2.) - 30:int(len(sci) / 2.) + 30]</span>
                    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="s1">&#39;Subtraction&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Background Subtraction</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">science_object</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Pixels (dispersion direction)&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Intensity (counts)&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sci</span><span class="p">)))</span>
                    <span class="c1"># plt.yscale(&#39;log&#39;)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Background Subtracted&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">unsubtracted</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Unsubtracted&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">subtracted_background</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Background&#39;</span><span class="p">)</span>
                    <span class="c1"># plt.plot(all_lamps[0],label=&#39;lamp 1&#39;)</span>
                    <span class="c1"># plt.plot(all_lamps[1],label=&#39;lamp 2&#39;)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
                    <span class="c1"># plt.savefig(&#39;background-subtraction_&#39;</span>
                    <span class="c1">#            + self.science_object.name</span>
                    <span class="c1">#            + &#39;_&#39;</span>
                    <span class="c1">#            + str(int(chebyshev(10)))</span>
                    <span class="c1">#            + &#39;.png&#39;, dpi=300)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">sci_pack</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;There are no traces discovered here!!.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="IdentifiedTarget"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.IdentifiedTarget">[docs]</a><span class="k">class</span> <span class="nc">IdentifiedTarget</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Allows for easy storage and manipulation of the targets found.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stddev</span><span class="p">,</span> <span class="n">fwhmg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">raw_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialization of class</span>

<span class="sd">        This class stores all the relevant information of an identified target in an image. The idea is to make use</span>
<span class="sd">        of the tools that classes provide to make it easy to handle.</span>

<span class="sd">        Args:</span>
<span class="sd">            amplitude (float): Peak value of the target&#39;s sample</span>
<span class="sd">            mean (float): Voigt fit center</span>
<span class="sd">            stddev (float): Full width at half maximum of Lorentzian component</span>
<span class="sd">            fwhmg (float): Full width at half maximum of Gaussian component</span>
<span class="sd">            raw_width (int): Width of the sample in dispersion axis.</span>
<span class="sd">            sample_loc (int): Location of the sample in the dispersion direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">amplitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stddev</span> <span class="o">=</span> <span class="n">stddev</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_g</span> <span class="o">=</span> <span class="n">fwhmg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_width</span> <span class="o">=</span> <span class="n">raw_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_loc</span> <span class="o">=</span> <span class="n">sample_loc</span>

<div class="viewcode-block" id="IdentifiedTarget.print_all"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.IdentifiedTarget.print_all">[docs]</a>    <span class="k">def</span> <span class="nf">print_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prints all the attributes of the identified target</span>

<span class="sd">        This is mostly for debugging purposes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Amplitude: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Mean: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Std Deviation: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stddev</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;FWHM (gauss): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_g</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Raw Width: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_width</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Sample Location: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_loc</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SciencePack"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.SciencePack">[docs]</a><span class="k">class</span> <span class="nc">SciencePack</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Science data packaging</span>

<span class="sd">    This class is designed to work as a packer of extracted data. The attributes are separated list for data, headers</span>
<span class="sd">    lamps data and lamps header. Their only matching mechanism is their index. therefore if you have added three science</span>
<span class="sd">    spectra and two comparison lamps, in order to get, say, de second one, you would have to get SciencePack.data[1]</span>
<span class="sd">    SciencePack.headers[1]. The same thing for the lamps.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;SciencePack initialization</span>

<span class="sd">        A SciencePack instance will be initialized having four empty list, lists that will store data an headers.</span>

<span class="sd">        Since data and headers are added in separated steps, there is no checks as for whether its been added</span>
<span class="sd">        consistently. Developer should be careful with this.</span>

<span class="sd">        Attributes:</span>
<span class="sd">            self.data (list): Stores science target data</span>
<span class="sd">            self.headers (list): Stores science target headers</span>
<span class="sd">            self.lamps_data (list): Stores comparison lamps data</span>
<span class="sd">            self.lamps_headers (list): Stores comparison lamps headers.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">headers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lamps_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lamps_headers</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="SciencePack.add_data"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.SciencePack.add_data">[docs]</a>    <span class="k">def</span> <span class="nf">add_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Appends science data&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="SciencePack.add_header"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.SciencePack.add_header">[docs]</a>    <span class="k">def</span> <span class="nf">add_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Appends science header&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_header</span><span class="p">)</span></div>

<div class="viewcode-block" id="SciencePack.add_lamp"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.SciencePack.add_lamp">[docs]</a>    <span class="k">def</span> <span class="nf">add_lamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_lamp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Appends comparison lamp data&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lamps_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_lamp</span><span class="p">)</span></div>

<div class="viewcode-block" id="SciencePack.add_lamp_header"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.SciencePack.add_lamp_header">[docs]</a>    <span class="k">def</span> <span class="nf">add_lamp_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_lamp_header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Appends comparison lamp header&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lamps_headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_lamp_header</span><span class="p">)</span></div>

<div class="viewcode-block" id="SciencePack.check_consistency"><a class="viewcode-back" href="../../goodman_spec.html#goodman_spec.process.SciencePack.check_consistency">[docs]</a>    <span class="k">def</span> <span class="nf">check_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that all stored data is consistent</span>

<span class="sd">        There should be the same number of _data_ and their respective</span>
<span class="sd">        _headers_, the same for _lamps\_data_ and _lamps\_headers_</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Science data and headers are consistent&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Science data and headers are not consistent&#39;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Data: </span><span class="si">{:d}</span><span class="s1">, Headers: </span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
                                                         <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lamps_data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lamps_headers</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Lamps data and headers are consistent&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Lamps data and headers are not consistent&#39;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Lamps: </span><span class="si">{:d}</span><span class="s1">, Headers: </span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
                                                         <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">)))</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Goodman Pipelines 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Simon Torres.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>